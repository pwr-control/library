% MIT License
% 
% Copyright (c) 2025 Davide Bagnara
% 
% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
% 
% The above copyright notice and this permission notice shall be included in all
% copies or substantial portions of the Software.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
% SOFTWARE.

component three_windings_transformer
% three windings transformer

    nodes
        u1_p = foundation.electrical.electrical; % u1(+):left
        u1_n = foundation.electrical.electrical; % u1(-):left        
        u2_p = foundation.electrical.electrical; % u2(+):right
        u2_n = foundation.electrical.electrical; % u2(-):right
        u3_p = foundation.electrical.electrical; % u3(+):right
        u3_n = foundation.electrical.electrical; % u3(-):right
    end
    
    outputs
        Bc = { 0, 'Wb/m^2' };                       % Bc:right
        phi_out = { 0, 'V*s' };                     % phi:right
        i1_out = { 0, 'A' };                        % i1_out:right
        i2_out = { 0, 'A' };                        % i2_out:right
        i3_out = { 0, 'A' };                        % i3_out:right
        im_out = { 0, 'A' };                        % im_out:right
        u1_out = { 0, 'V' };                        % u1_out:right
        u2_out = { 0, 'V' };                        % u2_out:right
        u3_out = { 0, 'V' };                        % u3_out:right
    end

    parameters
        Lm = {1.0e-3, 'H'};                % Lm1
        n1 = {3, '1'};                     % n1
        n2 = {3, '1'};                     % n2
        n3 = {3, '1'};                     % n3
        Rd1 = {2.0e-3, 'Ohm'};             % Rd1
        Rd2 = {2.0e-3, 'Ohm'};             % Rd2
        Rd3 = {2.0e-3, 'Ohm'};             % Rd3
        Ld1 = {6e-6, 'H'};                 % Ld1
        Ld2 = {12e-6, 'H'};                % Ld2
        Ld3 = {12e-6, 'H'};                % Ld3
        Rfe = {4e3, 'Ohm'};                % Rfe1
        length_m = {0.1, 'm'};             % length_m (m)
        mu0 = {1.256637e-6, 'H/m'};        % mu_0 (H/m)
        mur = {10e3, '1'};                 % mu_r
    end

    variables
        phi = { 0, 'V*s' };                     % phi
        i1 = { 0, 'A' };                        % i1
        i2 = { 0, 'A' };                        % i2
        i3 = { 0, 'A' };                        % i3
        ife = { 0, 'A' };                       % ife
        u1 = { 0, 'V' };                        % u1
        u2 = { 0, 'V' };                        % u2  
        u3 = { 0, 'V' };                        % u3  
    end


    branches
        i1 : u1_p.i -> u1_n.i;
        i2 : u2_p.i -> u2_n.i;
        i3 : u3_p.i -> u3_n.i;
    end

    equations
        let
            Reluctance = (n1)^2/Lm;
        in
            u1 == u1_p.v - u1_n.v;
            u2 == u2_p.v - u2_n.v;
            u3 == u3_p.v - u3_n.v;

            Reluctance * phi == (n1 * (i1-ife) + n2 * i2 + n3 * i3);
            u1 - Rd1 * i1 - Ld1 * i1.der - n1 * phi.der == 0;
            u2 - Rd2 * i2 - Ld2 * i2.der - n2 * phi.der == 0;
            u3 - Rd3 * i3 - Ld3 * i3.der - n3 * phi.der == 0;
            ife == (u1 - Rd1 * i1 - Ld1 * i1.der) / Rfe;

            phi_out == phi;
            Bc == (mu0 * mur) * (n1*(i1-ife) + n2*i2 + n3*i3) / length_m;
            i1_out == i1;
            i2_out == i2;
            i3_out == i3;
            im_out == i1_out + n2/n1*i2_out + n3/n1*i3_out;
            u1_out == u1;
            u2_out == u2;
            u3_out == u2;
        end
    end
end
